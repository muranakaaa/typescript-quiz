questions = [
  { content: "TypeScriptで文字列型を定義するにはどの型を使用しますか？", option1: "string", option2: "text", option3: "char", option4: "str", correct: 1 },
  { content: "数値型を定義する型は何ですか？", option1: "number", option2: "int", option3: "float", option4: "digit", correct: 1 },
  { content: "真偽値型を定義する型は何ですか？", option1: "boolean", option2: "bool", option3: "truefalse", option4: "binary", correct: 1 },
  { content: "未定義の値を表す型は何ですか？", option1: "undefined", option2: "null", option3: "void", option4: "empty", correct: 1 },
  { content: "値がないことを表す型は何ですか？", option1: "null", option2: "undefined", option3: "void", option4: "nothing", correct: 1 },
  { content: "型が動的に変わる変数にはどの型を使用しますか？", option1: "any", option2: "dynamic", option3: "object", option4: "unknown", correct: 1 },
  { content: "安全に使用するべきでない型は？", option1: "any", option2: "safe", option3: "never", option4: "unknown", correct: 1 },
  { content: "関数が値を返さない場合に使用する型は何ですか？", option1: "void", option2: "null", option3: "nothing", option4: "undefined", correct: 1 },
  { content: "TypeScriptで未知の型を扱う場合に使用する型は？", option1: "unknown", option2: "dynamic", option3: "object", option4: "any", correct: 1 },
  { content: "大きな整数値を扱う型は何ですか？", option1: "bigint", option2: "long", option3: "largeint", option4: "number", correct: 1 },
  { content: "文字列の配列を定義する型は？", option1: "string[]", option2: "str[]", option3: "textArray", option4: "Array<string[]>", correct: 1 },
  { content: "数値の配列を定義する方法を2つ挙げてください。", option1: "number[]", option2: "Array<number>", option3: "digitArray", option4: "numeric[]", correct: 1 },
  { content: "要素数と型が固定された配列を何と呼びますか？", option1: "タプル", option2: "リスト", option3: "配列", option4: "セット", correct: 1 },
  { content: "[1, 'hello']の型は？", option1: "[number, string]", option2: "[string, number]", option3: "Array<number | string>", option4: "string[]", correct: 1 },
  { content: "配列の各要素に異なる型が許容されるのは、配列型とタプル型のどちらですか？", option1: "タプル型", option2: "配列型", option3: "オブジェクト型", option4: "リスト型", correct: 1 },
  { content: "TypeScriptで空の配列を定義するには？", option1: "[]", option2: "null", option3: "empty[]", option4: "void[]", correct: 1 },
  { content: "文字列または数値を要素に持つ配列を定義する型は？", option1: "(string | number)[]", option2: "string & number[]", option3: "string | number[]", option4: "[string | number]", correct: 1 },
  { content: "可変長のタプルを定義する方法は？", option1: "[number, ...string[]]", option2: "[...number, string[]]", option3: "[number | string[]]", option4: "[number & string[]]", correct: 1 },
  { content: "配列におけるreadonly修飾子の役割は？", option1: "配列を変更不可能にする", option2: "配列に新しい型を追加する", option3: "配列を空にする", option4: "配列の値を初期化する", correct: 1 },
  { content: "readonly配列型を定義する方法は？", option1: "readonly number[]", option2: "readonly[number]", option3: "number readonly[]", option4: "Array<readonly number>", correct: 1 },
  { content: "オブジェクト型を定義する方法は？", option1: "{ key: type }", option2: "[key: type]", option3: "<key: type>", option4: "key: type", correct: 1 },
  { content: "プロパティがオプションの場合、どの記号を使用しますか？", option1: "?", option2: "*", option3: "optional", option4: "~", correct: 1 },
  { content: "次の型を読み解いてください: { name: string; age?: number }", option1: "nameは必須の文字列型、ageは省略可能な数値型", option2: "nameとageはどちらも省略可能", option3: "nameは省略可能な文字列型、ageは必須", option4: "nameとageは両方とも必須", correct: 1 },
  { content: "任意のプロパティを許容する型を定義するには？", option1: "[key: string]: type", option2: "any[key]: type", option3: "key: any[type]", option4: "{ any: type }", correct: 1 },
  { content: "型エイリアスを作成するキーワードは？", option1: "type", option2: "alias", option3: "interface", option4: "define", correct: 1 },
  { content: "次の型を読み解いてください: type User = { id: number; name: string }", option1: "Userはidとnameプロパティを持つオブジェクト型", option2: "Userはnumber型とstring型の配列", option3: "UserはUnion型", option4: "Userはエイリアス型ではない", correct: 1 },
  { content: "Union型を定義する演算子は？", option1: "|", option2: "&", option3: "||", option4: " +", correct: 1 },
  { content: "Intersection型を定義する演算子は？", option1: "&", option2: "|", option3: "&&", option4: "*", correct: 1 },
  { content: "次の型を読み解いてください: type Person = User & { age: number }", option1: "User型に加えてageプロパティを持つ型", option2: "User型のageプロパティを省略した型", option3: "Union型", option4: "配列型", correct: 1 },
  { content: "Partial<T>ユーティリティ型の役割は？", option1: "全プロパティをオプションにする", option2: "全プロパティを必須にする", option3: "特定のプロパティを除外する", option4: "型をエイリアス化する", correct: 1 },
  { content: "関数の戻り値に型を指定するには？", option1: "(): type", option2: "{ type }", option3: "[type]", option4: "<type>", correct: 1 },
  { content: "次の型を読み解いてください: (x: number, y: number) => number", option1: "2つの数値を受け取り、数値を返す関数型", option2: "2つの数値を受け取り、文字列を返す関数型", option3: "数値型の配列を返す関数型", option4: "2つの文字列を受け取る関数型", correct: 1 },
  { content: "引数が省略可能な場合、どの記号を使用しますか？", option1: "?", option2: "~", option3: "optional", option4: "*", correct: 1 },
  { content: "次の関数を型付けしてください: function greet(name) { return 'Hello, ' + name }", option1: "(name: string) => string", option2: "(name: number) => string", option3: "(name: string) => void", option4: "(name: any) => string", correct: 1 },
  { content: "デフォルト引数を型付けする方法は？", option1: "(x: number = 10) => void", option2: "(x: number, default = 10) => void", option3: "(x: number?) => void", option4: "(x: number?) => number", correct: 1 },
  { content: "関数型をオブジェクトに割り当てる方法は？", option1: "{ key: (param: type) => returnType }", option2: "{ key: type => returnType }", option3: "{ key: (param: type) -> returnType }", option4: "{ key: function(param: type) => returnType }", correct: 1 },
  { content: "次の型を読み解いてください: (x: string, y?: number) => void", option1: "文字列xは必須、数値yは省略可能で、戻り値はない関数型", option2: "文字列xは省略可能、数値yは必須で、戻り値は文字列型", option3: "文字列xと数値yは省略可能で、戻り値は文字列型", option4: "戻り値が数値型の関数型", correct: 1 },
  { content: "コールバック関数の型を指定する方法は？", option1: "(callback: (arg: type) => returnType) => void", option2: "callback: (arg: type) => returnType", option3: "(callback: type -> returnType) => void", option4: "(callback: { arg: type => returnType }) => void", correct: 1 },
  { content: "型アサーションを使用する演算子は？", option1: "as", option2: "is", option3: "like", option4: "typeof", correct: 1 },
  { content: "型アサーションを使うべき場合はどんな時ですか？", option1: "TypeScriptが型を正しく推測できない場合", option2: "型を除外したい場合", option3: "型を推測したい場合", option4: "型を強制的にnullにする場合", correct: 1 },
  { content: "列挙型（Enum）を定義するキーワードは？", option1: "enum", option2: "enumerable", option3: "list", option4: "set", correct: 1 },
  { content: "次のEnumを読み解いてください: enum Direction { Up, Down }", option1: "Up=0, Down=1の列挙型", option2: "Up=1, Down=0の列挙型", option3: "Up='Up', Down='Down'の列挙型", option4: "Directionは配列型", correct: 1 },
  { content: "ジェネリクスを定義する記号は？", option1: "<T>", option2: "[T]", option3: "{T}", option4: "(T)", correct: 1 },
  { content: "次の型を読み解いてください: Array<T>", option1: "型Tの配列", option2: "T型のオブジェクト", option3: "T型のタプル", option4: "T型の関数", correct: 1 },
  { content: "`readonly`修飾子の役割は？", option1: "プロパティや変数を変更不可能にする", option2: "プロパティや変数を削除可能にする", option3: "型を固定する", option4: "型を省略する", correct: 1 },
  { content: "型ガードに使用するキーワードは？", option1: "is", option2: "as", option3: "typeof", option4: "guard", correct: 1 },
  { content: "`never`型はどんな時に使用されますか？", option1: "決して値を返さない関数や状態", option2: "未定義の型を示す時", option3: "配列が空の時", option4: "型を無視する時", correct: 1 },
  { content: "型エイリアスとインターフェースの違いは？", option1: "インターフェースは拡張可能、型エイリアスは拡張できない", option2: "型エイリアスは拡張可能、インターフェースは拡張できない", option3: "型エイリアスは配列専用、インターフェースはオブジェクト専用", option4: "違いはない", correct: 1 },
  { content: "条件型を表す構文は？", option1: "T extends U ? X : Y", option2: "if T extends U then X else Y", option3: "T or U -> X or Y", option4: "T -> U -> X or Y", correct: 1 },
  { content: "TypeScriptの型推論が働くケースを1つ挙げてください。", option1: "変数に初期値を代入した時", option2: "型を指定しない時に型を除外する", option3: "型を明示的に定義した時", option4: "型アサーションを使用した時", correct: 1 }
]

questions.each do |q|
  Question.create!(q)
end
